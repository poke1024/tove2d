{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the T\u00d6VE Docs.","title":"Welcome to the T\u00d6VE Docs."},{"location":"#welcome-to-the-tove-docs","text":"","title":"Welcome to the T\u00d6VE Docs."},{"location":"features/","text":"Scope T\u00d6VE is a simplified vector graphics library for games aimed at realtime scaling and animation. Even though T\u00d6VE knows some tricks and even supports dithering, do not expect it to have the feature set or the rendering quality comparable of a full fledged print quality library such as Cairo or Skia . Renderers Here's what you can expect from T\u00d6VE's different renderers: texture mesh 1 mesh 2 gpux Holes Support \u25cf \u25cf \u25cf 4 \u25cf Non-Zero Fill Rule \u25cf \u25cf \u25cb \u25cf Even-Odd Fill Rule \u25cf \u25cf \u25cb \u25cf Clip Paths \u25cf \u25cf \u25cb \u25cb Solid Colors \u25cf \u25cf \u25cf \u25cf Linear Gradients \u25cf \u25cf \u25cf \u25cf Radial Gradients \u25cf \u25cf \u25cf \u25cf Thick Lines \u25cf \u25cf \u25cf \u25cf Non-Opaque Lines \u25cf \u25cf \u25cb \u25cf Miter Joins \u25cf \u25cf \u25cf \u25cf Bevel Joins \u25cf \u25cf \u25cf \u25cf Round Joins \u25cf \u25cf \u25cb \u25cf 3 Line Dashes \u25cf \u25cf \u25cb \u25cb Line Caps \u25cf \u25cf \u25cb \u25cb Also note the number of OpenGL drawing calls/context switches: texture mesh gpux 1 per Graphics 1 per Graphics >= 1 per Path if used as static mesh, i.e. building it once and not animating its shape. \u21a9 if used as animated mesh, i.e. when calling setUsage on \"points\" with \"dynamic\" or \"stream\". \u21a9 for some shapes, by using the fragment option for line rendering. \u21a9 for some shapes, hole polygons must not intersect non-hole polygons. \u21a9","title":"Features"},{"location":"features/#scope","text":"T\u00d6VE is a simplified vector graphics library for games aimed at realtime scaling and animation. Even though T\u00d6VE knows some tricks and even supports dithering, do not expect it to have the feature set or the rendering quality comparable of a full fledged print quality library such as Cairo or Skia .","title":"Scope"},{"location":"features/#renderers","text":"Here's what you can expect from T\u00d6VE's different renderers: texture mesh 1 mesh 2 gpux Holes Support \u25cf \u25cf \u25cf 4 \u25cf Non-Zero Fill Rule \u25cf \u25cf \u25cb \u25cf Even-Odd Fill Rule \u25cf \u25cf \u25cb \u25cf Clip Paths \u25cf \u25cf \u25cb \u25cb Solid Colors \u25cf \u25cf \u25cf \u25cf Linear Gradients \u25cf \u25cf \u25cf \u25cf Radial Gradients \u25cf \u25cf \u25cf \u25cf Thick Lines \u25cf \u25cf \u25cf \u25cf Non-Opaque Lines \u25cf \u25cf \u25cb \u25cf Miter Joins \u25cf \u25cf \u25cf \u25cf Bevel Joins \u25cf \u25cf \u25cf \u25cf Round Joins \u25cf \u25cf \u25cb \u25cf 3 Line Dashes \u25cf \u25cf \u25cb \u25cb Line Caps \u25cf \u25cf \u25cb \u25cb Also note the number of OpenGL drawing calls/context switches: texture mesh gpux 1 per Graphics 1 per Graphics >= 1 per Path if used as static mesh, i.e. building it once and not animating its shape. \u21a9 if used as animated mesh, i.e. when calling setUsage on \"points\" with \"dynamic\" or \"stream\". \u21a9 for some shapes, by using the fragment option for line rendering. \u21a9 for some shapes, hole polygons must not intersect non-hole polygons. \u21a9","title":"Renderers"},{"location":"release-notes/","text":"[master] Added: Noise for texture gradients 2.0a2 Fixed: Compiler glitches 2.0a1 Changed: API for specifying tesselation quality Fixed: gpux now works on a wider range of devices Added: Dithered texture gradients Added: More robust XML / SVGs parsing Added: Better clip path support (Inkscape) Fixed: Reduced uniform buffer size on mesh rendering Fixed: Animation of gradients and colors Added: Various optimizations Added: Runtime warnings Fixed: Various other bugs 1.0 First complete proof of concept","title":"Release Notes"},{"location":"release-notes/#master","text":"Added: Noise for texture gradients","title":"[master]"},{"location":"release-notes/#20a2","text":"Fixed: Compiler glitches","title":"2.0a2"},{"location":"release-notes/#20a1","text":"Changed: API for specifying tesselation quality Fixed: gpux now works on a wider range of devices Added: Dithered texture gradients Added: More robust XML / SVGs parsing Added: Better clip path support (Inkscape) Fixed: Reduced uniform buffer size on mesh rendering Fixed: Animation of gradients and colors Added: Various optimizations Added: Runtime warnings Fixed: Various other bugs","title":"2.0a1"},{"location":"release-notes/#10","text":"First complete proof of concept","title":"1.0"},{"location":"tutorials/Animation/","text":"Animating Things T\u00d6VE is designed for allowing animating and changing shapes and colors at runtime without getting inefficient. Animating with the Stage API Many animations can be achieved by moving, rotating and scaling certain fixed parts of a graphics. T\u00d6VE offers the retained Stage API for simplifying these kind of animations (also see the Stage API documentation ). At the core is the Shape object. Each Shape holds a Graphics you can access. Each Shape knows about its own position, rotation and scale. You can change these at any time and they will stay this way across frames until you change them again. So if you have objects on the screen and only want to move some of them, Shape might simplify your code. For drawing, Shapes need to added to a Stage . Here's an example: local stage = tove.newStage() local shape = tove.newShape() shape.graphics:drawCircle(0, 0, 100) shape.graphics:setFillColor(0.7, 0.2, 0.3) shape.graphics:fill() -- add this shape to the stage. from now on -- it will get rendered with the stage. stage:addChild(shape) function love.draw() -- change the position of our shape. shape.x = love.mouse.getX() shape.y = love.mouse.getY() stage:draw() end Flipbooks and Animations Let's say you have a couple of SVGs that you want to play back like some sort of sprite sheet. T\u00d6VE has two kinds of API to support you with this. Also see T\u00d6VE's API documentation on animation function . First, there are flipbooks. These are prerendered distinct frames. Think of a sprite atlas being played back. Second, there are animations. These are interpolated in real time, i.e. they are not prerendered. Note that for these, T\u00d6VE expects all frames to have exactly the same path layout (same number of trajectories and points across all frames) 1 . The \"blob\" demo has code for both animation styles. Tweens For both flipbooks and animations, the first thing to do is to create a tween that gathers all the keyframes and durations, much like a timeline in an animation program. Tweens can be created from Graphics or from SVG text data like this: svg1 = love.filesystem.read(\"frame1.svg\") svg2 = love.filesystem.read(\"frame2.svg\") tween = tove.newTween(svg1):to(svg2, 1) The code above creates a tween of two frames, where the second frame happens one second after the other. You can add more frames by calling to . So, tove.newTween(svg1):to(svg2, 1):to(svg3, 5) would create a tween that adds an additional frame 5 seconds after the second. to takes an optional third parameter which allows you to ease the transition. It expects a one-parameter Lua function that maps (0, 1). Flipbooks Flipbooks consist of distinct prerendered frames. That means flipbooks have high quality but only a discrete time resolution. Creating a flipbook is easy: f = tove.newFlipbook(8, tween) This creates a flipbook with 8 frames per second, i.e. it prerenders the tween at this frame rate. You can animate this flipbook by calling f:draw() and by setting f.t for its current time (in tween time, i.e. this is not a frame number). You can also specify what kind of renderer you want to use for the distinct frames. bitmap is the default, but you can also choose mesh which will prerender your frames as adaptive meshes. You can also specify quality settings as optional follow-up parameters. Animations Animations are frames interpolated and rendered in realtime. That means animations have a continuous time resolution but can also be expensive in terms of rendering. Animations are created like this: a = tove.newAnimation(tween, \"mesh\") As with flipbooks, you can use a:draw() to draw the current frame, and a.t to set the time. Looping By default, animations and flipbooks interpolate as if they bounce forth and back. If you want to look your animation, make sure to transition to the first frame at the end of the tween. This indicates to T\u00d6VE that you want a continuous interpolation from first to last: tween = tove.newTween(svg1):to(svg2, 1):to(svg1, 1) A Technical Note If you're using animations with the \"mesh\" display mode, T\u00d6VE will use a fixed resolution flattening and try to precalculate all triangulations. That means that the quality will be lower than for adaptive meshes, but things should be fast. Procedural Animation Features Sometimes you want even more flexibility for some kind of procedural animation: freely animate colors and gradients of a path in realtime freely animate a path by modifying its control points in realtime T\u00d6VE can do this. Take a look at the \"hearts\" demo to see working code. Here are some hints: The first step to animate colors or points is to tell your Graphics instance about it: call Graphics:setUsage to animate points (the shape of your drawing) or colors (the fill or stroke color of your drawing) or both. myDrawing:setUsage(\"points\", \"stream\") -- animate points myDrawing:setUsage(\"colors\", \"stream\") -- animate colors Without doing this, T\u00d6VE will not be able to animate your objects efficiently and things will be slow. Please note that T\u00d6VE does not efficiently support animations that add or delete points. You can also choose to use \"dynamic\" instead of \"stream\" if your shapes change frequently, but not on every frame (also see L\u00d6VE's docs on SpriteBatchUsage ). Animating colors Animating colors is easy. Here are two examples: Animating by re-setting the color To animate the triangle from the Getting Started section, you could do this: function love.draw() local t = love.timer.getTime() -- current time local r, g, b = math.abs(math.sin(t)), 0.4, 0.2 myDrawing.paths[1]:setFillColor(tove.newColor(r, g, b)) end Note that we do not call setFillColor on the Graphics as that would only change the next new path we fill using Graphics:fill() . As we actively want to change the color of an already existing path, we need to grab that path using myDrawing.paths[1] . Of course, if you'd like the line color to change, you'd call setLineColor instead. Animating by changing the color A slightly different approach is changing the color itself: local myColor = tove.newColor() myDrawing.paths[1]:setFillColor(myColor) function love.draw() local r = math.abs(math.sin(love.timer.getTime())) myColor:set(r, 0.4, 0.2) RGB colors can be read and changed by either set(r, g, b, a) and r, g, b, a = get() or directly via attributes, e.g. someColor.r = 0.3 . So the code above could also be written as: local myColor = tove.newColor(0.0, 0.4, 0.2) myDrawing.paths[1]:setFillColor(myColor) function love.draw() myColor.r = math.abs(math.sin(love.timer.getTime())) Animating shapes with Commands Most drawing calls come return a command, that allows you to animate what you have just drawn. Also see the API documentation on Commands . An example: local shape = tove.newGraphics() shape.moveTo(10, 10) local myLineTo = shape.lineTo(100, 100) shape.moveTo(-50, 200) At any point later in your code, you can now modify the lineTo command: myLineTo.x = 200 This has the same effect as if you'd recreated the whole graphics with the modified lineTo , but it's much faster - using mutable commands, T\u00d6VE will animate stuff very efficiently (for example, for the mesh renderer, this boils down to a Mesh:setVertices call in L\u00d6VE). The attribute names are x and y for moveTo and lineTo . For curveTo you also have cp1x , cp1y , cp2x , cp2y . You can read and write those properties. Directly Accessing Paths and Curves Using Command is what you want to animate one path most of the time. Sometimes though want to have a broader access to your curve data. For example you might want to morph whole parts of a path. T\u00d6VE let's you do this. Also see the Curve API documentation . Let's first talk about how T\u00d6VE stores your curves and how it names things: A Graphics is a collection of Path s A Path is a collection of Subpath s (plus fill and stroke styles etc.) A Subpath consists of Curve s A Curve is a cubic bezier curve and consists of four control points With this scheme, you can access paths, subpaths and curves (all indices are 1-based): local myCurve = myGraphics.paths[1].subpaths[2].curves[5] Once you have picked a curve, you can modify its points by accessing its attributes x0 , y0 , cp1x , cp1y , cp2x , cp2y , x , y (the latter 6 correspond to the parameters you'd pass to Graphics:curveTo ). This works for reading and writing. For example, to animate the x target point of curve 1 of some graphics using your mouse, you might do this: function love.draw() myDrawing.paths[1].subpaths[1].curves[1].x = love.mouse.getX() myDrawing:Draw() end If you want to access a curve's underlying points by index, you can do it like this: myGraphics.paths[1].subpaths[2].curves[1].p[2].x myGraphics.paths[1].subpaths[2].curves[3].p[2].y To find out how many paths, subpaths, curves or points you have, you can use the count attribute, e.g.: myDrawing.paths.count -- number of paths myDrawing.paths[1].subpaths.count -- number of subpaths in path 1 myDrawing.paths[1].subpaths[1].points.count -- number of points in subpath 1 in path 1 if this is not the case, T\u00d6VE is able to morph shapes (see demos/morph). \u21a9","title":"Animating Things"},{"location":"tutorials/Animation/#animating-things","text":"T\u00d6VE is designed for allowing animating and changing shapes and colors at runtime without getting inefficient.","title":"Animating Things"},{"location":"tutorials/Animation/#animating-with-the-stage-api","text":"Many animations can be achieved by moving, rotating and scaling certain fixed parts of a graphics. T\u00d6VE offers the retained Stage API for simplifying these kind of animations (also see the Stage API documentation ). At the core is the Shape object. Each Shape holds a Graphics you can access. Each Shape knows about its own position, rotation and scale. You can change these at any time and they will stay this way across frames until you change them again. So if you have objects on the screen and only want to move some of them, Shape might simplify your code. For drawing, Shapes need to added to a Stage . Here's an example: local stage = tove.newStage() local shape = tove.newShape() shape.graphics:drawCircle(0, 0, 100) shape.graphics:setFillColor(0.7, 0.2, 0.3) shape.graphics:fill() -- add this shape to the stage. from now on -- it will get rendered with the stage. stage:addChild(shape) function love.draw() -- change the position of our shape. shape.x = love.mouse.getX() shape.y = love.mouse.getY() stage:draw() end","title":"Animating with the Stage API"},{"location":"tutorials/Animation/#flipbooks-and-animations","text":"Let's say you have a couple of SVGs that you want to play back like some sort of sprite sheet. T\u00d6VE has two kinds of API to support you with this. Also see T\u00d6VE's API documentation on animation function . First, there are flipbooks. These are prerendered distinct frames. Think of a sprite atlas being played back. Second, there are animations. These are interpolated in real time, i.e. they are not prerendered. Note that for these, T\u00d6VE expects all frames to have exactly the same path layout (same number of trajectories and points across all frames) 1 . The \"blob\" demo has code for both animation styles.","title":"Flipbooks and Animations"},{"location":"tutorials/Animation/#tweens","text":"For both flipbooks and animations, the first thing to do is to create a tween that gathers all the keyframes and durations, much like a timeline in an animation program. Tweens can be created from Graphics or from SVG text data like this: svg1 = love.filesystem.read(\"frame1.svg\") svg2 = love.filesystem.read(\"frame2.svg\") tween = tove.newTween(svg1):to(svg2, 1) The code above creates a tween of two frames, where the second frame happens one second after the other. You can add more frames by calling to . So, tove.newTween(svg1):to(svg2, 1):to(svg3, 5) would create a tween that adds an additional frame 5 seconds after the second. to takes an optional third parameter which allows you to ease the transition. It expects a one-parameter Lua function that maps (0, 1).","title":"Tweens"},{"location":"tutorials/Animation/#flipbooks","text":"Flipbooks consist of distinct prerendered frames. That means flipbooks have high quality but only a discrete time resolution. Creating a flipbook is easy: f = tove.newFlipbook(8, tween) This creates a flipbook with 8 frames per second, i.e. it prerenders the tween at this frame rate. You can animate this flipbook by calling f:draw() and by setting f.t for its current time (in tween time, i.e. this is not a frame number). You can also specify what kind of renderer you want to use for the distinct frames. bitmap is the default, but you can also choose mesh which will prerender your frames as adaptive meshes. You can also specify quality settings as optional follow-up parameters.","title":"Flipbooks"},{"location":"tutorials/Animation/#animations","text":"Animations are frames interpolated and rendered in realtime. That means animations have a continuous time resolution but can also be expensive in terms of rendering. Animations are created like this: a = tove.newAnimation(tween, \"mesh\") As with flipbooks, you can use a:draw() to draw the current frame, and a.t to set the time.","title":"Animations"},{"location":"tutorials/Animation/#looping","text":"By default, animations and flipbooks interpolate as if they bounce forth and back. If you want to look your animation, make sure to transition to the first frame at the end of the tween. This indicates to T\u00d6VE that you want a continuous interpolation from first to last: tween = tove.newTween(svg1):to(svg2, 1):to(svg1, 1)","title":"Looping"},{"location":"tutorials/Animation/#a-technical-note","text":"If you're using animations with the \"mesh\" display mode, T\u00d6VE will use a fixed resolution flattening and try to precalculate all triangulations. That means that the quality will be lower than for adaptive meshes, but things should be fast.","title":"A Technical Note"},{"location":"tutorials/Animation/#procedural-animation-features","text":"Sometimes you want even more flexibility for some kind of procedural animation: freely animate colors and gradients of a path in realtime freely animate a path by modifying its control points in realtime T\u00d6VE can do this. Take a look at the \"hearts\" demo to see working code. Here are some hints: The first step to animate colors or points is to tell your Graphics instance about it: call Graphics:setUsage to animate points (the shape of your drawing) or colors (the fill or stroke color of your drawing) or both. myDrawing:setUsage(\"points\", \"stream\") -- animate points myDrawing:setUsage(\"colors\", \"stream\") -- animate colors Without doing this, T\u00d6VE will not be able to animate your objects efficiently and things will be slow. Please note that T\u00d6VE does not efficiently support animations that add or delete points. You can also choose to use \"dynamic\" instead of \"stream\" if your shapes change frequently, but not on every frame (also see L\u00d6VE's docs on SpriteBatchUsage ).","title":"Procedural Animation Features"},{"location":"tutorials/Animation/#animating-colors","text":"Animating colors is easy. Here are two examples:","title":"Animating colors"},{"location":"tutorials/Animation/#animating-by-re-setting-the-color","text":"To animate the triangle from the Getting Started section, you could do this: function love.draw() local t = love.timer.getTime() -- current time local r, g, b = math.abs(math.sin(t)), 0.4, 0.2 myDrawing.paths[1]:setFillColor(tove.newColor(r, g, b)) end Note that we do not call setFillColor on the Graphics as that would only change the next new path we fill using Graphics:fill() . As we actively want to change the color of an already existing path, we need to grab that path using myDrawing.paths[1] . Of course, if you'd like the line color to change, you'd call setLineColor instead.","title":"Animating by re-setting the color"},{"location":"tutorials/Animation/#animating-by-changing-the-color","text":"A slightly different approach is changing the color itself: local myColor = tove.newColor() myDrawing.paths[1]:setFillColor(myColor) function love.draw() local r = math.abs(math.sin(love.timer.getTime())) myColor:set(r, 0.4, 0.2) RGB colors can be read and changed by either set(r, g, b, a) and r, g, b, a = get() or directly via attributes, e.g. someColor.r = 0.3 . So the code above could also be written as: local myColor = tove.newColor(0.0, 0.4, 0.2) myDrawing.paths[1]:setFillColor(myColor) function love.draw() myColor.r = math.abs(math.sin(love.timer.getTime()))","title":"Animating by changing the color"},{"location":"tutorials/Animation/#animating-shapes-with-commands","text":"Most drawing calls come return a command, that allows you to animate what you have just drawn. Also see the API documentation on Commands . An example: local shape = tove.newGraphics() shape.moveTo(10, 10) local myLineTo = shape.lineTo(100, 100) shape.moveTo(-50, 200) At any point later in your code, you can now modify the lineTo command: myLineTo.x = 200 This has the same effect as if you'd recreated the whole graphics with the modified lineTo , but it's much faster - using mutable commands, T\u00d6VE will animate stuff very efficiently (for example, for the mesh renderer, this boils down to a Mesh:setVertices call in L\u00d6VE). The attribute names are x and y for moveTo and lineTo . For curveTo you also have cp1x , cp1y , cp2x , cp2y . You can read and write those properties.","title":"Animating shapes with Commands"},{"location":"tutorials/Animation/#directly-accessing-paths-and-curves","text":"Using Command is what you want to animate one path most of the time. Sometimes though want to have a broader access to your curve data. For example you might want to morph whole parts of a path. T\u00d6VE let's you do this. Also see the Curve API documentation . Let's first talk about how T\u00d6VE stores your curves and how it names things: A Graphics is a collection of Path s A Path is a collection of Subpath s (plus fill and stroke styles etc.) A Subpath consists of Curve s A Curve is a cubic bezier curve and consists of four control points With this scheme, you can access paths, subpaths and curves (all indices are 1-based): local myCurve = myGraphics.paths[1].subpaths[2].curves[5] Once you have picked a curve, you can modify its points by accessing its attributes x0 , y0 , cp1x , cp1y , cp2x , cp2y , x , y (the latter 6 correspond to the parameters you'd pass to Graphics:curveTo ). This works for reading and writing. For example, to animate the x target point of curve 1 of some graphics using your mouse, you might do this: function love.draw() myDrawing.paths[1].subpaths[1].curves[1].x = love.mouse.getX() myDrawing:Draw() end If you want to access a curve's underlying points by index, you can do it like this: myGraphics.paths[1].subpaths[2].curves[1].p[2].x myGraphics.paths[1].subpaths[2].curves[3].p[2].y To find out how many paths, subpaths, curves or points you have, you can use the count attribute, e.g.: myDrawing.paths.count -- number of paths myDrawing.paths[1].subpaths.count -- number of subpaths in path 1 myDrawing.paths[1].subpaths[1].points.count -- number of points in subpath 1 in path 1 if this is not the case, T\u00d6VE is able to morph shapes (see demos/morph). \u21a9","title":"Directly Accessing Paths and Curves"},{"location":"tutorials/Demos/","text":"The Demos You might wonder at this point, what you gain with T\u00d6VE over simply rasterizing your vector graphics to textures via an export step from your vector drawing software. It's flexibility. Let's take a quick look at some of T\u00d6VE's demos , as they explain a lot about the core ideas and capabilities of T\u00d6VE. Running the Demos Check out the whole repo from GitHub. To run the demos, the lib and assets folders need to be accessible from inside the demos. On macOS and Linux, the demos contain symbolic links, and all you need to do is to unzip T\u00d6VE's lib into the repo's root like this: demos docs lib libTove.dylib ... LICENSE ... Then you can start one demo, e.g. the zoom demo, using: cd demos/zoom love . On Windows, the symbolic links don't work :-( So you need to unzip the lib into each demo folder. Also you need to copy the demos/assets folder inside the respective demo folder. Basically: replace the symlinks with the real stuff. Warp Demo A demo allowing you to change shape and character of curves on any SVG using a brush-like interface. Best of all, you can define various frames in this way and then animate between them using a mesh rendering: Renderers Demo Interactively zoom T\u00d6VE's three renderers to inspect the quality of each variant. Note that startup takes time due to the compilation of the gpux shaders: Tesselation Demo The mesh renderer's quality setting produces meshes of different detail and triangle count from the same SVG: Zoom Demo Scaling bitmaps produces blurriness or pixelation, scaling meshes produces straight crisp lines, while T\u00d6VE's unique shader-based gpux renderer will render crisp curves at many reasonable scales: Blob Demo Animate between two SVGs using different renderers and qualities: The SVGs have been exported as animation from one single timeline from Smith Micro Moho. As Moho uses one underlying geometry for all exported frame (defined on frame 1 in the timeline), all SVGs share the same path and point layout, which allows for interpolation in T\u00d6VE. Hearts Demo Procedurally animate geometry and colors (here: a linear gradient) through different renderers: The numbers displayed are times spent inside love.graphics.draw (might not be representative as more work might happen later in the swap of the GL context). The mesh and gpux renderers update existing GPU data structures like meshes and shader textures without recreating them, which allows for higher frame rates. This demo illustrates two internal variants of the mesh renderer: one uses flat meshes (if no gradients are exist), the other uses shaders for gradient renderers. mesh automatically chooses the right internal variant. Fill Rule Demo T\u00d6VE offers support for holes and fill rules for all of its renderers: Clip Path Demo For non-animated rendering, T\u00d6VE is able to render rather complex clip paths in texture and mesh modes. In this SVG by Chris Hildenbrand, there are about 200 wildly nested clip paths: Retro Rasterization Demo For non-animated rasterization, T\u00d6VE supports various dithering modes for rendering gradients with limited palettes: MiniEdit Demo T\u00d6VE comes with a mini editor that lets you explore all of T\u00d6VE's features (different renderers and settings) interactively. You can drag and drop any SVG into the editor. It also has a demo mode that lets you benchmark performance:","title":"The Demos"},{"location":"tutorials/Demos/#the-demos","text":"You might wonder at this point, what you gain with T\u00d6VE over simply rasterizing your vector graphics to textures via an export step from your vector drawing software. It's flexibility. Let's take a quick look at some of T\u00d6VE's demos , as they explain a lot about the core ideas and capabilities of T\u00d6VE.","title":"The Demos"},{"location":"tutorials/Demos/#running-the-demos","text":"Check out the whole repo from GitHub. To run the demos, the lib and assets folders need to be accessible from inside the demos. On macOS and Linux, the demos contain symbolic links, and all you need to do is to unzip T\u00d6VE's lib into the repo's root like this: demos docs lib libTove.dylib ... LICENSE ... Then you can start one demo, e.g. the zoom demo, using: cd demos/zoom love . On Windows, the symbolic links don't work :-( So you need to unzip the lib into each demo folder. Also you need to copy the demos/assets folder inside the respective demo folder. Basically: replace the symlinks with the real stuff.","title":"Running the Demos"},{"location":"tutorials/Demos/#warp-demo","text":"A demo allowing you to change shape and character of curves on any SVG using a brush-like interface. Best of all, you can define various frames in this way and then animate between them using a mesh rendering:","title":"Warp Demo"},{"location":"tutorials/Demos/#renderers-demo","text":"Interactively zoom T\u00d6VE's three renderers to inspect the quality of each variant. Note that startup takes time due to the compilation of the gpux shaders:","title":"Renderers Demo"},{"location":"tutorials/Demos/#tesselation-demo","text":"The mesh renderer's quality setting produces meshes of different detail and triangle count from the same SVG:","title":"Tesselation Demo"},{"location":"tutorials/Demos/#zoom-demo","text":"Scaling bitmaps produces blurriness or pixelation, scaling meshes produces straight crisp lines, while T\u00d6VE's unique shader-based gpux renderer will render crisp curves at many reasonable scales:","title":"Zoom Demo"},{"location":"tutorials/Demos/#blob-demo","text":"Animate between two SVGs using different renderers and qualities: The SVGs have been exported as animation from one single timeline from Smith Micro Moho. As Moho uses one underlying geometry for all exported frame (defined on frame 1 in the timeline), all SVGs share the same path and point layout, which allows for interpolation in T\u00d6VE.","title":"Blob Demo"},{"location":"tutorials/Demos/#hearts-demo","text":"Procedurally animate geometry and colors (here: a linear gradient) through different renderers: The numbers displayed are times spent inside love.graphics.draw (might not be representative as more work might happen later in the swap of the GL context). The mesh and gpux renderers update existing GPU data structures like meshes and shader textures without recreating them, which allows for higher frame rates. This demo illustrates two internal variants of the mesh renderer: one uses flat meshes (if no gradients are exist), the other uses shaders for gradient renderers. mesh automatically chooses the right internal variant.","title":"Hearts Demo"},{"location":"tutorials/Demos/#fill-rule-demo","text":"T\u00d6VE offers support for holes and fill rules for all of its renderers:","title":"Fill Rule Demo"},{"location":"tutorials/Demos/#clip-path-demo","text":"For non-animated rendering, T\u00d6VE is able to render rather complex clip paths in texture and mesh modes. In this SVG by Chris Hildenbrand, there are about 200 wildly nested clip paths:","title":"Clip Path Demo"},{"location":"tutorials/Demos/#retro-rasterization-demo","text":"For non-animated rasterization, T\u00d6VE supports various dithering modes for rendering gradients with limited palettes:","title":"Retro Rasterization Demo"},{"location":"tutorials/Demos/#miniedit-demo","text":"T\u00d6VE comes with a mini editor that lets you explore all of T\u00d6VE's features (different renderers and settings) interactively. You can drag and drop any SVG into the editor. It also has a demo mode that lets you benchmark performance:","title":"MiniEdit Demo"},{"location":"tutorials/Getting_Started/","text":"Getting Started Some info to get you started. Installation To install T\u00d6VE, grab T\u00d6VE's binaries package and unzip it inside your L\u00d6VE project (as a folder called tove ). You should then be able to load T\u00d6VE using tove = require \"tove\" . T\u00d6VE's folder contains four files: init.lua : a Lua library binding to love libTove.dll : T\u00d6VE library (for Windows) libTove.dylib : T\u00d6VE library (for macOS) libTove.so : T\u00d6VE library (for Linux) Since you're running only on one platform, you'd only need one of the binary files, but they are all included for convenience. Drawing a Triangle Let's draw a triangle. First import T\u00d6VE as described above. Then create a Graphics instance, which is the main API for drawing in T\u00d6VE: local tove = require \"tove\" local myDrawing = tove.newGraphics() Graphics provides various functions of drawing and works similar to a canvas. Here comes our triangle: myDrawing:moveTo(100, 100) myDrawing:lineTo(200, 250) myDrawing:lineTo(50, 220) myDrawing:fill() moveTo moves your drawing brush to an absolute position. lineTo then draws two lines. fill finally tells T\u00d6VE to close the shape (i.e. supplement the missing third line) and fill it (with the current fill color). To see what we've drawn, we need to display the Graphics instance to the screen like this: function love.draw() myDrawing:draw() end Now you should see the image below; note that the coordinates you put into the moveTo and lineTo earlier correspond to the position of the triangle on L\u00d6VE screen. Wow, very impressive, no? Ok, you could indeed add some color by calling setFillColor before doing the fill : myDrawing:setFillColor(0.8, 0.4, 0.6) myDrawing:fill() Note: setFillColor can take RGBA values, but you can also specify HTML colors , e.g. setFillColor(#80AA20) . At this point, you might wonder what T\u00d6VE is about. All this can be done with L\u00d6VE as well. So on to the next section: Curves, lines and gradients While T\u00d6VE supports straight lines, curves are its real matter. Let's bend one side of our triangle by replacing the first lineTo from above with a curveTo , which will draw a cubic bezier curve: myDrawing:moveTo(100, 100) myDrawing:curveTo(120, 100, 210, 200, 200, 250) myDrawing:lineTo(50, 220) myDrawing:setFillColor(0.8, 0.4, 0.6) myDrawing:fill() curveTo takes the positions of two control points (x1, y1, x2, y2) and one target point (x, y). Together with the previous starting point this makes four points to define the cubic bezier curve. This is a good place to note that you can also use drawCircle(x, y, r) and drawEllipse(x, y, rx, ry) to draw circles and ellipses, and drawRect(x, y, w, h, rx, ry) to draw (rounded) rectangles. Let's continue with our triangle. Adding a bluish stroke of line width 10 is as simple as appending this code: myDrawing:setLineColor(0.2, 0.4, 0.6) myDrawing:setLineWidth(10) myDrawing:stroke() Now, instead of a solid purple fill, let's use a linear gradient to make things more interesting: local gradient = tove.newLinearGradient(120, 130, 140, 160) gradient:addColorStop(0, 0.8, 0.4, 0.6) gradient:addColorStop(1, 0.6, 0.2, 0.6) myDrawing:setFillColor(gradient) myDrawing:fill() Importing SVGs Yes, you can import SVGs, and it's as simple as this: local rabbit = love.filesystem.read(\"assets/rabbit.svg\") local myRabbit = tove.newGraphics(rabbit, 200) function love.draw() love.graphics.translate(250, 250) myRabbit:draw() end The call to newGraphics takes the actual SVG data that was loaded via love.filesystem.read . The optional second parameter, 200 , tells T\u00d6VE to prescale the graphics to 200 pixels. If this is omitted, the SVG's natural scaling will be used, which assumes you know its exact scaling. Note that after loading the SVG, T\u00d6VE no longer cares whether it's dealing with an SVG or a manually constructed graphics (meaning you can change the renderer and so on).","title":"Getting Started"},{"location":"tutorials/Getting_Started/#getting-started","text":"Some info to get you started.","title":"Getting Started"},{"location":"tutorials/Getting_Started/#installation","text":"To install T\u00d6VE, grab T\u00d6VE's binaries package and unzip it inside your L\u00d6VE project (as a folder called tove ). You should then be able to load T\u00d6VE using tove = require \"tove\" . T\u00d6VE's folder contains four files: init.lua : a Lua library binding to love libTove.dll : T\u00d6VE library (for Windows) libTove.dylib : T\u00d6VE library (for macOS) libTove.so : T\u00d6VE library (for Linux) Since you're running only on one platform, you'd only need one of the binary files, but they are all included for convenience.","title":"Installation"},{"location":"tutorials/Getting_Started/#drawing-a-triangle","text":"Let's draw a triangle. First import T\u00d6VE as described above. Then create a Graphics instance, which is the main API for drawing in T\u00d6VE: local tove = require \"tove\" local myDrawing = tove.newGraphics() Graphics provides various functions of drawing and works similar to a canvas. Here comes our triangle: myDrawing:moveTo(100, 100) myDrawing:lineTo(200, 250) myDrawing:lineTo(50, 220) myDrawing:fill() moveTo moves your drawing brush to an absolute position. lineTo then draws two lines. fill finally tells T\u00d6VE to close the shape (i.e. supplement the missing third line) and fill it (with the current fill color). To see what we've drawn, we need to display the Graphics instance to the screen like this: function love.draw() myDrawing:draw() end Now you should see the image below; note that the coordinates you put into the moveTo and lineTo earlier correspond to the position of the triangle on L\u00d6VE screen. Wow, very impressive, no? Ok, you could indeed add some color by calling setFillColor before doing the fill : myDrawing:setFillColor(0.8, 0.4, 0.6) myDrawing:fill() Note: setFillColor can take RGBA values, but you can also specify HTML colors , e.g. setFillColor(#80AA20) . At this point, you might wonder what T\u00d6VE is about. All this can be done with L\u00d6VE as well. So on to the next section:","title":"Drawing a Triangle"},{"location":"tutorials/Getting_Started/#curves-lines-and-gradients","text":"While T\u00d6VE supports straight lines, curves are its real matter. Let's bend one side of our triangle by replacing the first lineTo from above with a curveTo , which will draw a cubic bezier curve: myDrawing:moveTo(100, 100) myDrawing:curveTo(120, 100, 210, 200, 200, 250) myDrawing:lineTo(50, 220) myDrawing:setFillColor(0.8, 0.4, 0.6) myDrawing:fill() curveTo takes the positions of two control points (x1, y1, x2, y2) and one target point (x, y). Together with the previous starting point this makes four points to define the cubic bezier curve. This is a good place to note that you can also use drawCircle(x, y, r) and drawEllipse(x, y, rx, ry) to draw circles and ellipses, and drawRect(x, y, w, h, rx, ry) to draw (rounded) rectangles. Let's continue with our triangle. Adding a bluish stroke of line width 10 is as simple as appending this code: myDrawing:setLineColor(0.2, 0.4, 0.6) myDrawing:setLineWidth(10) myDrawing:stroke() Now, instead of a solid purple fill, let's use a linear gradient to make things more interesting: local gradient = tove.newLinearGradient(120, 130, 140, 160) gradient:addColorStop(0, 0.8, 0.4, 0.6) gradient:addColorStop(1, 0.6, 0.2, 0.6) myDrawing:setFillColor(gradient) myDrawing:fill()","title":"Curves, lines and gradients"},{"location":"tutorials/Getting_Started/#importing-svgs","text":"Yes, you can import SVGs, and it's as simple as this: local rabbit = love.filesystem.read(\"assets/rabbit.svg\") local myRabbit = tove.newGraphics(rabbit, 200) function love.draw() love.graphics.translate(250, 250) myRabbit:draw() end The call to newGraphics takes the actual SVG data that was loaded via love.filesystem.read . The optional second parameter, 200 , tells T\u00d6VE to prescale the graphics to 200 pixels. If this is omitted, the SVG's natural scaling will be used, which assumes you know its exact scaling. Note that after loading the SVG, T\u00d6VE no longer cares whether it's dealing with an SVG or a manually constructed graphics (meaning you can change the renderer and so on).","title":"Importing SVGs"},{"location":"tutorials/Renderers/","text":"Setting Renderers This section should give you some idea of why there are three different renderers in T\u00d6VE, what they do, and when you want to change things. This extends on the information given in the API documentation on display modes . The renderers T\u00d6VE provides three renderers to bring vector graphics to the screen: texture , mesh and gpux : texture is the default renderer. It gives high quality and high performance for static images that don't need animation or scaling. Internally, this is NanoSVG rendering to a texture. mesh uses a triangle mesh to produce a tessellated version of the graphics, which is then drawn using a L\u00d6VE Mesh . Scaling will not produce pixelation, but crisp straight edges. Using this renderer, curves and colors can be animated efficiently. gpux is a purely shader-based renderer that gives high quality at different resolutions. It's a very complex shader and quite experimental (it's not been done before AFAIK). It allows for efficient animation of curves and colors. You can tell T\u00d6VE which renderer to use by calling Graphics:setDisplay(mode, quality...) on your Graphics instance, e.g. myDrawing:setDisplay(\"mesh\") . The next call to Graphics:draw() will then honor that setting. The optional quality parameter is a render-dependent number that allows you to configure the level of detail for some renderers. Let's try this out. With the curved triangle from the Getting Started section, let's set a mesh renderer before drawing: myDrawing:setDisplay(\"mesh\") function love.draw() myDrawing:draw() end You might notice that the bottom right edge looks a bit edgy now. That's due to the mesh's default quality setting. To see that we're really dealing with a mesh, let's increase that effect by telling T\u00d6VE to use even less triangles: myDrawing:setDisplay(\"mesh\", 100) -- specify the target resolution in pixels to define tesselation detail One of the strengths of T\u00d6VE is that choosing the display renderer is independent of building your geometry and colors. Which renderer is right for me? Here are some hints: texture gives great quality, but is slow for re-rendering and scaling via transforms will produce pixelation, unless you re-render for a higher resolution. You can tell T\u00d6VE at which resolution to render internally by using Graphics:setResolution (this won't affect the display size, but you'll see that a resolution of 2 will allow you to scale the image by a factor of 2 without seeing pixelation). mesh is the best all-round solution if you need to dynamically scale your graphics. Once you determine a detail level that matches your requirements (in terms of scaling and zoom), you're basically dealing with a L\u00d6VE Mesh , which is efficient to draw, scale and animate. gpux can give excellent results in terms of quality and performance in some situations. Then again, it can be expensive in terms of shader performance and there can be issues with numerical stability 1 . Setting the mesh renderer quality If you're using the \"mesh\" display mode, the quality setting in Graphics:setDisplay lets you change the level of the detail the mesh renderer tessellates its mesh. In most cases, you should specify a tesselation using \"adaptive\" or \"rigid\" . For example Graphics:setDisplay(\"mesh\", \"adaptive\", 1024) will render a mesh that should look good when drawn at a size of 1024 pixels. T\u00d6VE allows a second option, where you only specify a single number, e.g. Graphics:setDisplay(\"mesh\", 1024) . In that case, T\u00d6VE will look at the mesh's usage (see Graphics:setUsage ) and come up with a suitable tesselator. If your usage is static , T\u00d6VE will create a \"adaptive\" tesselator, if your usage is dynamic or stream , the tesselator will be \"rigid\" . The second factor to mention here is Graphics:setResolution . If you specified a quality of 1024 , but also set a resolution of 2 , you will in fact get a quality that's good for 2048 pixels. Mesh renderer quality and MSAA By default the mesh renderer looks rather pixelated. You can fix this by increasing the MSAA settings of your window like this (see Love2D docs on config files ): function love.conf(t) t.window.msaa = 2 end Thanks to pdesaulniers for reporting this . The mesh renderer and gradients The mesh renderer automatically detects if you are using gradients or not. If not, it internally uses a flat mesh of vertices and colors. If you use gradients, it will use a shader implementation for the coloring. computing cubic roots in a shader using 16 bit floating point numbers might not only seem potty but indeed has some limits. \u21a9","title":"Choosing Renderers"},{"location":"tutorials/Renderers/#setting-renderers","text":"This section should give you some idea of why there are three different renderers in T\u00d6VE, what they do, and when you want to change things. This extends on the information given in the API documentation on display modes .","title":"Setting Renderers"},{"location":"tutorials/Renderers/#the-renderers","text":"T\u00d6VE provides three renderers to bring vector graphics to the screen: texture , mesh and gpux : texture is the default renderer. It gives high quality and high performance for static images that don't need animation or scaling. Internally, this is NanoSVG rendering to a texture. mesh uses a triangle mesh to produce a tessellated version of the graphics, which is then drawn using a L\u00d6VE Mesh . Scaling will not produce pixelation, but crisp straight edges. Using this renderer, curves and colors can be animated efficiently. gpux is a purely shader-based renderer that gives high quality at different resolutions. It's a very complex shader and quite experimental (it's not been done before AFAIK). It allows for efficient animation of curves and colors. You can tell T\u00d6VE which renderer to use by calling Graphics:setDisplay(mode, quality...) on your Graphics instance, e.g. myDrawing:setDisplay(\"mesh\") . The next call to Graphics:draw() will then honor that setting. The optional quality parameter is a render-dependent number that allows you to configure the level of detail for some renderers. Let's try this out. With the curved triangle from the Getting Started section, let's set a mesh renderer before drawing: myDrawing:setDisplay(\"mesh\") function love.draw() myDrawing:draw() end You might notice that the bottom right edge looks a bit edgy now. That's due to the mesh's default quality setting. To see that we're really dealing with a mesh, let's increase that effect by telling T\u00d6VE to use even less triangles: myDrawing:setDisplay(\"mesh\", 100) -- specify the target resolution in pixels to define tesselation detail One of the strengths of T\u00d6VE is that choosing the display renderer is independent of building your geometry and colors.","title":"The renderers"},{"location":"tutorials/Renderers/#which-renderer-is-right-for-me","text":"Here are some hints: texture gives great quality, but is slow for re-rendering and scaling via transforms will produce pixelation, unless you re-render for a higher resolution. You can tell T\u00d6VE at which resolution to render internally by using Graphics:setResolution (this won't affect the display size, but you'll see that a resolution of 2 will allow you to scale the image by a factor of 2 without seeing pixelation). mesh is the best all-round solution if you need to dynamically scale your graphics. Once you determine a detail level that matches your requirements (in terms of scaling and zoom), you're basically dealing with a L\u00d6VE Mesh , which is efficient to draw, scale and animate. gpux can give excellent results in terms of quality and performance in some situations. Then again, it can be expensive in terms of shader performance and there can be issues with numerical stability 1 .","title":"Which renderer is right for me?"},{"location":"tutorials/Renderers/#setting-the-mesh-renderer-quality","text":"If you're using the \"mesh\" display mode, the quality setting in Graphics:setDisplay lets you change the level of the detail the mesh renderer tessellates its mesh. In most cases, you should specify a tesselation using \"adaptive\" or \"rigid\" . For example Graphics:setDisplay(\"mesh\", \"adaptive\", 1024) will render a mesh that should look good when drawn at a size of 1024 pixels. T\u00d6VE allows a second option, where you only specify a single number, e.g. Graphics:setDisplay(\"mesh\", 1024) . In that case, T\u00d6VE will look at the mesh's usage (see Graphics:setUsage ) and come up with a suitable tesselator. If your usage is static , T\u00d6VE will create a \"adaptive\" tesselator, if your usage is dynamic or stream , the tesselator will be \"rigid\" . The second factor to mention here is Graphics:setResolution . If you specified a quality of 1024 , but also set a resolution of 2 , you will in fact get a quality that's good for 2048 pixels.","title":"Setting the mesh renderer quality"},{"location":"tutorials/Renderers/#mesh-renderer-quality-and-msaa","text":"By default the mesh renderer looks rather pixelated. You can fix this by increasing the MSAA settings of your window like this (see Love2D docs on config files ): function love.conf(t) t.window.msaa = 2 end Thanks to pdesaulniers for reporting this .","title":"Mesh renderer quality and MSAA"},{"location":"tutorials/Renderers/#the-mesh-renderer-and-gradients","text":"The mesh renderer automatically detects if you are using gradients or not. If not, it internally uses a flat mesh of vertices and colors. If you use gradients, it will use a shader implementation for the coloring. computing cubic roots in a shader using 16 bit floating point numbers might not only seem potty but indeed has some limits. \u21a9","title":"The mesh renderer and gradients"}]}